---
title: "CH4--0429"
author: "YI XUAN HSU"
date: "2020/5/4"
output: html_document
---

## 4.3 On numeric class  數值向量運算

->加、減、乘、除： +, -, *, /

```{r}
a <- c(2, 3, 5)
b <- c(4,-1, 3)
```

```{r}
a+b    #做各對相同位置的相加--> elementwise (個別元素) operation
a-b
a*b
a/b
```

->餘數：%%
->次方：** 或 ^

```{r}
a %% b
# 相當於
c(2%%4, 3%%(-1), 5%%3)

a ** b    # 等於2^4 =16  3^-1 =1/3  5^3 =125
```

->奇、偶數判斷

```{r}
sequenceNums <- c(11, 6, 8, 11, 12, 11, 3, 7, 10, 8)

print(sequenceNums)

sequenceNums %% 2    #餘數為1則是奇數，0則是偶數
```


在多數時候R向量間的運算都是elementwise(個別元素)的運算：
所有向量一一取出各自對應相同位置的元素值進行運算。

```{r}
# a+b 即等於
c(2+4, 3+(-1), 5+3)

# a**b 即等於
c(2**4, 3**(-1), 5**3)
```


當向量間不等長度時，R則對短的向量進行Recycle的動作
（即Python的Broadcast）:
將其中較短的向量**反複堆疊到可以長得跟最長的向量一樣長度**

```{r}
5*c(1,3,4)+7
# 其實是
c(5)*c(1,3,4)+c(7)

# 對向量5，向量7進行recycle到等長:
c(5,5,5)*c(1,3,4)+c(7,7,7)

# Recycle等長後才進行elementwise operation:
c(5*1+7, 5*3+7, 5*4+7)
```

當運算的兩物件內容長度不同時，則將其中較短的一個反複堆疊到可以長得跟另一個一樣高時才來運算，稱為recycling。

```{r}
# 狀況一: 堆疊一定倍數剛好一樣長

c(2,3)/c(-2,-13,10,22)
# 相當於
c(2,3,2,3)/c(-2,-13,10,22)
```

```{r}
# 狀況二: 倍數堆疊一定會超過，只好截斷

c(2,3)/c(-2,-13,10)
# 相當於
c(2,3,2)/c(-2,-13,10) #會出現警訊提醒兩項個數不是倍數關係 但還是可算
```


Recycling不只用在數值class， 只要向量間的處理要等長度才合理時，recycling通常也會用在其他的class

```{r}
paste0(
  c("我叫"), c("小明","小美") )

#也等於是
paste0(
  c("我叫","我叫"), c("小明","小美") )
```

```{r}
paste0(
  c("他叫","我叫"), c("小明","小美","大雄"))
```


## 4.4 Relational Operators  關聯判斷：比大小

這節在介紹產生「要/不要」向量的常見手法
=> Relational Operators 操作完呈現 要/不要 的 邏輯class 向量

```{r}
example <- list(
  name=c("小明","小花","小新","美美"),
  height=c(175,166,170,160),
  weight=c(77,NA,60,43),
  birthday=lubridate::ymd(c("1998-03-11","1999-12-22","1995-08-22","2001-10-10")),
  hobby=c("美食 旅遊","旅遊 時尚","3C 美食","音樂 旅遊"),
  residence=c("Taipei","New Taipei","Taichung","Kaohsiung"),
  allowance=factor(c("0-1000","1001-2000","2000+","1001-2000")),
  bloodType=c("A","B","B","O")
)
```


# 4.4.1 比較

` > , < , <= , >= ` : 分別為大於、小於、小於等於、大於等於

1. 數字比較
2. 時間比較
3. 可排序類別資料比較


*1. 數字比較

EX：example裡誰的身高大於等於170
```{r}
str(example[c("name","height")])

pick_above170 <- example$height >= 170

example$height

c(175, 166, 170, 160) >= 170
#相當於
example$name[c(T, F, T, F)]    #之前學的方式

example$name[pick_above170]
```


EX：不同屆入學學生在2年級的學業表現
```{r}
source("https://www.dropbox.com/s/qsrw069n94k61lj/transcript100to103_list.R?dl=1")
```

```{r}
str(transcript100to103)
```

分析情境：
```{r}
# 各學屆2年級人數
table(transcript100to103$`學屆`)#table適用可以分類、數數量的類別資料

# 各學屆2年級成績大於85人數
table(transcript100to103$`學屆`[pick_above85]) #想要創造出來pick這項
```

選成績大於85分    #創造出上方 [pick_above85] 這項
```{r}
# 只要成績大於85的
pick_above85 <- transcript100to103$`成績` > 85
```

重新再跑一次：
```{r}
# 各學屆2年級人數
table(transcript100to103$`學屆`)

# 各學屆2年級成績大於85人數
table(transcript100to103$`學屆`[pick_above85])
```


*2. 時間比較

EX：example裡誰1998年(含)以後出生
```{r}
example$birthday

class(example$birthday)
typeof(example$birthday)
```

```{r}
print(example[c("name","birthday")])

pick_after98 <- example$birthday >= lubridate::ymd("1998-01-01")    #要比較的雙方，一定要是同一個class，因此使用lubridate 轉成Date class

example$name[pick_after98]
```


EX：美元匯率
```{r}
source("https://www.dropbox.com/s/16h6ggua6qtydci/exchangeRate.R?dl=1")
```

```{r}
str(exchangeRate)
```

情境：
```{r}
exchangeRate_after98 <-
  list(
    `期間`=exchangeRate$`期間`[pick_after98_01],
    `幣別`=exchangeRate$`幣別`[pick_after98_01],
    `匯率`=exchangeRate$`匯率`[pick_after98_01]
  )
```

選1998年1月(含)以後的匯率    #創造出上方 [pick_after98_01] 這項
```{r}
library(lubridate)

# 只要1998年1月（含）以後的 (使用大於等於，表示與過去的某一時間相距了多少秒，秒數愈長愈接近現在)
pick_after98_01 <-
  exchangeRate$`期間` >= ymd("1998-01-01") 
```

選出1998年1月(含)以後的匯率資料 (重新再跑一次)
```{r}
exchangeRate_after98 <-
  list(
    `期間`=exchangeRate$`期間`[pick_after98_01],
    `幣別`=exchangeRate$`幣別`[pick_after98_01],
    `匯率`=exchangeRate$`匯率`[pick_after98_01]
  )
```


*3. "可排序"類別資料比較

EX：example裡誰零用錢大於1000:
```{r}
print(example[c("name","allowance")])   # allowance的class為factor

pick_allowanceOver1000 <- example$allowance >= "1001-2000"
example$name[pick_allowanceOver1000]
# 不可排序的類別資料比大小是沒有意義的
```

factor資料可進一步分成可排序，與不可排序的，如：
* 可排序： 以年齡層區分的類別，以所得級距區分的類別等。
* 不排序： 性別，學系等。

factor的設定在不調整時內定為不可排序資料，如要改成可排序類別資料，以先前已處理好的example$allowance 為例：

```{r}
levels(example$allowance)    #先確認此level順序就是我們想要的排序

example$allowance <- ordered(example$allowance)    
# 再使用ordered 指令裡放入factor元素，表示與電腦告知此factor 是有經過排序過後的 -->可排序、可比較

class(example$allowance)
```

設定完後重新再跑一次
```{r}
pick_allowanceOver1000 <- example$allowance >= "1001-2000"
example$name[pick_allowanceOver1000]
```

或在設定為factor時即把levels排好，並ordered=T：
```{r}
example$allowance <-
  factor(
    example$allowance,
    levels=c("0-1000", "1001-2000", "2000+"),  
      #若原本level的排序不是我們要的，可從這裡自行調整排序
    ordered = T    #設定為可排序factor
  )
```

```{r}
pick_allowanceOver1000 <- example$allowance >= "1001-2000"
example$name[pick_allowanceOver1000]
```


EX：刑事案件被害者人數
https://data.gov.tw/dataset/36240

```{r}
jsonlite::fromJSON("https://www.dropbox.com/s/3uijub7xheib405/list_victimAges_female.json?dl=1", simplifyDataFrame = F) -> list_victimAges_female
```

```{r}
str(list_victimAges_female)

View(list_victimAges_female$`數目`)    #項目裡包含一些缺失值(NA)

sum(list_victimAges_female$`數目`) #當項目裡含有缺失值時，無法做計算
sum(list_victimAges_female$`數目`, na.rm=T) 
    # rm=remove (移除)，表示值裡面若有出現(NA)的都會被移除，不用理會
```

(1) 請將list_victimAges_female各元素的class做合理設定
```{r}
list_victimAges_female$`數目` <-
  as.integer(list_victimAges_female$`數目`)

list_victimAges_female$`年齡層` <- 
  as.factor(list_victimAges_female$`年齡層`)
```

```{r}
levels(list_victimAges_female$`年齡層`) -> levels_ages

print(levels_ages)
```

(2) 將levels順序改成: 不詳，總計，0_5歲，12_17歲，…，70歲以上
```{r}
levels_new <- c(levels_ages[c(12,13,1,8,2:7,9:11)])
levels(list_victimAges_female$`年齡層`) <- levels_new
```


情境
```{r}
sum(list_victimAges_female$`數目`, na.rm=T)
sum(list_victimAges_female$`數目`[pick_above30], na.rm = T)
```

可選出「30_39歲以上受害者」的「要/不要」向量：    #創造出上方 [pick_above30] 這項
```{r}
# 先將類別資料設定成可排序類別資料
list_victimAges_female$`年齡層` <-
  ordered(list_victimAges_female$`年齡層`)

pick_above30 <- 
  list_victimAges_female$`年齡層` >= "30_39歲"
```

選出「30_39歲以上受害者」的數目 (創造好後重新再跑一次)
```{r}
sum(list_victimAges_female$`數目`, na.rm=T)
sum(list_victimAges_female$`數目`[pick_above30], na.rm = T)
```


# 4.4.2 相等，屬於

==: 等於    #兩個等號
!=: 不等於
==與!=可使用於字串

EX：example裡誰血型B型
```{r}
print(example[c("name","bloodType")])

pick_bloodB <- example$bloodType == "B"
example$name[pick_bloodB]
```

```{r}
sequenceNums <- c(11, 6, 8, 11, 12, 11, 3, 7, 10, 8)

pick_evens <- (sequenceNums %% 2) == 0    #關聯性分析通常為同一class
  #創造可留下偶數的「要/不要」向量pick_evens

sequenceNums[pick_evens]
```

還有一個常用的關聯運算：

%in%: 屬於

左邊元素「一一」檢視是不是屬於右邊元素*集合*

```{r}
x <- c(1,5,8)
y <- c(5,8)

# x裡的元素值是不是屬於y集合
x %in% y    #呈現的結果為邏輯向量 T or F
```

EX：example裡誰來自大台北
```{r}
print(example[c("name","residence")])

set_TaipeiMetro <- c("Taipei","New Taipei")
pick_fromTaipeiMetro <- example$residence %in% set_TaipeiMetro
 #當有符合多種可能的狀況且狀況相等，使用'集合' %in% "屬於"的方式運算

example$name[pick_fromTaipeiMetro]
```


EX：創造 可選出來自法商學院的「要/不要」向量，pick_lawBusiness
```{r}
source("https://www.dropbox.com/s/qsrw069n94k61lj/transcript100to103_list.R?dl=1")
```

```{r}
str(transcript100to103)

levels(factor(transcript100to103$`學院`))
#先確認資料使用的各院對應名稱是什麼

#也可使用unique，使重複出現的元素值呈現一次就好，結果都為獨一無二的
unique(transcript100to103$`學院`)

set_LawBusiness <- c("法學院","商學院")

pick_LawBusiness <- transcript100to103$`學院` %in% set_LawBusiness
```


# 4.4.3 Negation(否定用法)

在「要/不要」向量前加上!會成為否定句的「要/不要」向量，元素裡的TRUE會轉成FALSE, FALSE則轉成TRUE

"!" 通常都為 Negation 的用法

```{r}
pick_not_fromTaipeiMetro <- ! pick_fromTaipeiMetro

# 或
pick_not_fromTaipeiMetro <- 
  !(example$residence %in% set_TaipeiMetro)    
   # (..) 裡面會先運算完才做外面!的處理
```

```{r}
print(example[c("name","residence")])

example$name[pick_fromTaipeiMetro]
example$name[pick_not_fromTaipeiMetro]
```







